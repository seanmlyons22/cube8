/*
 * Code to controll an 8x8x8 ledcube using avr
 * http://www.instructables.com/id/Led-Cube-8x8x8/
 * See lisence.txt for license.
 */
#include "main.h"
#include "effect.h"
#include "launch_effect.h"
#include "draw.h"

// Main loop
// the AVR enters this function at boot time
int main (void)
{

    // This function initiates IO ports, timers, interrupts and
    // serial communications
    ioinit();

    // This variable specifies which layer is currently being drawn by the
    // cube interrupt routine. We assign a value to it to make sure it's not >7.
    current_layer = 1;

    int i;

    // Enable interrupts
    // This starts the routine that draws the cube content
    sei();

    // Do awesome effects. Loop forever.
    while (1)
    {
        // Show the effects in a predefined order
        for (i=0; i<EFFECTS_TOTAL; i++)
            launch_effect(i);

        // Show the effects in a random order.
        // Comment the two lines above and uncomment this
        // if you want the effects in a random order.
        //launch_effect(rand()%EFFECTS_TOTAL);
    }

}

/*
 * Multiplexer/framebuffer routine
 * This function is called by an interrupt generated by timer 2.
 * Every time it runs, it does the following:
 * 1) Disable the output for the multiplexer array.
 * 2) Turn of all layers.
 * 3) Load the current layer from the cube buffer onto the
 *    multiplexer array.
 * 4) Enable output from the multiplexer array.
 * 5) Turn on the current layer.
 * 6) Increment the current_layer variable, so the next layer is
 *    drawn the next time this function runs.
 */
ISR(TIMER0_COMPA_vect)
{
    int i;

    LAYER_SELECT = 0x00; // Turn all cathode layers off. (all transistors off)
    OE_PORT |= OE_MASK; // Set OE high, disabling all outputs on latch array

    // Loop through all 8 bytes of data in the current layer
    // and latch it onto the cube.
    for (i = 0; i < 8; i++)
    {
        // Set the data on the data-bus of the latch array.
        PORTA = cube[current_layer][i];
        // Increment the latch address chip, 74HC138, to create
        // a rising edge (LOW to HIGH) on the current latch.
        LATCH_ADDR = (LATCH_ADDR & LATCH_MASK_INV) | (LATCH_MASK & (i+1));
    }

    OE_PORT &= ~OE_MASK; // Set OE low, enabling outputs on the latch array
    LAYER_SELECT = (0x01 << current_layer); // Transistor ON for current layer

    // Increment the curren_layer counter so that the next layer is
    // drawn the next time this function runs.
    current_layer++;
    // We want to count from 0-7, so set it to 0 when it reaches 8.
    if (current_layer == 8)
        current_layer = 0;
}

void ioinit (void)
{
    DDRA = 0xFF;    // DATA bus output
    DDRB |= 0x0F;   // Lower nibble of B is output
    DDRC = 0xFF;    // Layer select output
    DDRD |= 0x1C;   // PD[4:2] are outputs, LEDs


    PORTA = 0x00; // Set data bus off
    PORTC = 0x00; // Set layer select off
    PORTB = 0x00; // Enable pull up on button.


    // Timer 0
    // Frame buffer interrupt
    // 14745600/256/6 = 9600 interrupts per second
    // 9600/8 = 1200 frames per second
    OCR0A = 5;  // interrupt at counter = 10
    TCCR0B |= (1 << CS02); // Prescaler = 256.
    TCCR0A |= (1 << WGM01); // CTC mode. Reset counter when OCR2 is reached.
    TCNT0 = 0x00;   // initial counter value = 0;
    TIMSK0 |= (1 << OCIE0A); // Enable CTC interrupt
}
